--- 
- import_playbook: tasks/check_all.yml

- name: Deploy VMs
  hosts: openshift_upi_vms # openshift_upi_vms_master_nodes[0]:openshift_upi_vms_worker_nodes[1]
  gather_facts: false
  vars_files:
  - passwords/ansible_vault.yml
  - vars/network-config.yml
  tasks:

  - name: Combine customized VM config
    set_fact:
      community_vmware_vmware__guest: "{{ default_community_vmware_vmware__guest | combine(custom_community_vmware_vmware__guest | default({}), recursive=true) }}"
      ansible_becomes_password: "{{ client_password }}"
    tags: always

  # - name: Ensure Ansible become password is set
  #   set_fact:
  #     ansible_become_password: "{{ deployment_password }}"
  #   when: ansible_become_password is undefined or ansible_become_password != deployment_password
  #   tags: always

  # - name: biep
  #   debug:
  #     msg: "{{ vars.community_vmware_vmware__guest }}"

  # - name: Deploy DNS records - BROKEN
  #   vars:
  #     target_group_dns: "{{ ansible_play_hosts }}" #"{{ groups.rhel_vms }}"
  #   ansible.builtin.include_tasks: tasks/deploy-windows-dns-records.yml

  - name: Deploy VMs
    ansible.builtin.include_tasks:
      file: tasks/deploy-vmware-vms-from-template.yml
      apply:
        tags: vm
    tags: vm


- name: Prepare OpenShift deployment
  hosts: localhost
  gather_facts: false
  become: true
  vars_files:
  - passwords/ansible_vault.yml
  - vars/network-config.yml
  - group_vars/openshift_upi_vms.yml
  - group_vars/vcenter_vms.yml
  tasks:

  - name: OpenShift deployment preparation
    tags: openshift
    block:

    - name: Create config & install dir
      file:
        path: "{{ item }}"
        state: directory
      with_items:
      - "{{ vars.openshift_config_dir }}"
      - "{{ vars.openshift_download_dir }}"


    - name: Download specific sources
      get_url:
        url: "{{ vars.openshift_custom_version_source }}"
        dest: "{{ vars.openshift_download_dir }}/openshift-install-linux.tar.gz"
      when: vars.openshift_custom_version_source | length > 0

    - name: Download default stable sources if no specific version is set
      get_url:
        url: "{{ vars.openshift_default_source }}"
        dest: "{{ vars.openshift_download_dir }}/openshift-install-linux.tar.gz"
      when: vars.openshift_custom_version_source | length <= 0
    
    - name: Untar the installation file
      unarchive:
        src: "{{ vars.openshift_download_dir }}/openshift-install-linux.tar.gz"
        dest: "{{ vars.openshift_download_dir }}"
        creates: "{{ vars.openshift_download_dir }}/openshift-install"


    - name: Download default stable client
      get_url:
        url: "{{ vars.openshift_default_client_source }}"
        dest: "{{ vars.openshift_download_dir }}/openshift-client-linux.tar.gz"
    
    - name: Untar the client file
      unarchive:
        src: "{{ vars.openshift_download_dir }}/openshift-client-linux.tar.gz"
        dest: "{{ vars.openshift_download_dir }}"
        creates: "{{ vars.openshift_download_dir }}/oc"
    
    # - name: Copy client files to the local user's bin, instead of /usr/local/bin which would need become
    #   copy:
    #     src: "{{ item }}"
    #     dest: $HOME/bin/
    #   with_items: 
    #   - "{{ vars.openshift_download_dir }}/oc"
    #   - "{{ vars.openshift_download_dir }}/kubectl"

    - name: Copy client files to /usr/local/bin for all users
      copy:
        src: "{{ item }}"
        dest: /usr/local/bin
      with_items: 
      - "{{ vars.openshift_download_dir }}/oc"
      - "{{ vars.openshift_download_dir }}/kubectl"

    - name: Check whether new SSH key is already created
      include_tasks: tasks/check_local_ssh_key_creation.yml
      run_once: true

    - name: Read SSH key
      slurp:
        src: "~/.ssh/{{ vars.deployment_ssh_filename }}.pub"
      register: sshKey
      
    - name: Check whether manifests were already created
      stat:
        path: "{{ vars.openshift_config_dir }}/manifests"
      register: manifests_dir

    - name: Check whether ignition files were already created
      stat:
        path: "{{ vars.openshift_config_dir }}/master.ign"
      register: ignition_file

    - name: Create manifests
      when: not manifests_dir.stat.exists and not ignition_file.stat.exists
      block:

      - name: Template out the inventory file to the config dir
        template:
          src: vars/openshift_4_upi_install_config_vmware.yml
          dest: "{{ vars.openshift_config_dir }}/install-config.yaml"
          force: no

      - name: Take a copy of the install-config as a backup
        copy:
          src: "{{ vars.openshift_config_dir }}/install-config.yaml"
          dest: "{{ vars.openshift_config_dir }}/install-config.yaml.bak"
          force: no

      - name: Create manifest files
        shell: "{{ vars.openshift_download_dir }}/openshift-install create manifests --dir {{ vars.openshift_config_dir }}"
  
      - name: Remove unneeded manifest files
        file:
          path: "{{ item }}"
          state: absent
        with_fileglob:
        - "{{ vars.openshift_config_dir }}/openshift/99_openshift-cluster-api_master-machines-*.yaml"
        - "{{ vars.openshift_config_dir }}/openshift/99_openshift-cluster-api_worker-machineset-*.yaml"
        
      - name: Set masters to non-Schedulable
        replace:
          path: "{{ vars.openshift_config_dir }}/manifests/cluster-scheduler-02-config.yml"
          regexp: 'mastersSchedulable: true'
          replace: 'mastersSchedulable: false'


    - name: Create ignition files
      shell: "{{ vars.openshift_download_dir }}/openshift-install create ignition-configs --dir {{ vars.openshift_config_dir }}"
      when: not ignition_file.stat.exists
 
    - name: Query the cluster's random identifier
      shell: "jq -r .infraID {{ vars.openshift_config_dir }}/metadata.json"
      register: cluster_id

    - name: Report cluster name
      debug:
        msg: "Cluster ID: {{ cluster_id.stdout }}"


  - name: Configure a web server for the ignition files
    tags:
    - web
    - openshift
    block:
  
      - name: Install podman
        ansible.builtin.yum:
          name: podman
          state: latest
  
      - name: Allow traffic to httpd on port 8080
        ansible.posix.firewalld:
          zone: public
          port: 8080/tcp
          permanent: yes
          state: enabled
        vars:
          ansible_python_interpreter: /usr/bin/python3.6
  
      - name: Pull Apache httpd container image
        containers.podman.podman_image:
          name: httpd
          pull: true
          tag: latest
  
      - name: Configure webroot - permissions
        file:
          path: "{{ vars.bastion_webroot }}"
          state: directory
          mode: '0777'

      - name: Configure webroot - SELinux file context, should be idempotent, isn't...
        become: yes
        community.general.sefcontext:
          target: "{{ vars.bastion_webroot }}(/.*)?"
          setype: "container_share_t"
          state: present
        register: webroot_dir_fcontext
        vars:
          ansible_python_interpreter: /usr/bin/python3.6

      - name: Create a custom index.html
        copy:
          dest: "{{ vars.bastion_webroot }}/index.html"
          content: |
            Custom Web Page, hosting ignition files
  
      - name: Copy the ignition file
        copy:
          src: "{{ vars.openshift_config_dir }}/bootstrap.ign"
          dest: "{{ vars.bastion_webroot }}/bootstrap.ign"
  
      - name: Apply SELinux fcontext if it wasn't already added
        become: yes
        shell: restorecon -irv {{ vars.bastion_webroot }}
        when: webroot_dir_fcontext.changed
  
      - name: Run Apache httpd container
        containers.podman.podman_container:
          name: webserver
          image: httpd
          state: started
          detach: true
          expose:
          - 80
          ports:
            - 8080:80
          volume:
          - "{{ vars.bastion_webroot }}:/usr/local/apache2/htdocs/:exec"

      - name: Query index.html
        shell: curl http://127.0.0.1:8080/index.html 
        register: index_curl

      - name: Show output received from web server
        debug:
          msg: "Output index.html: {{ index_curl.stdout }}"

      - name: Query bootstrap ignition
        shell: curl http://127.0.0.1:8080/bootstrap.ign
        register: bootstrap_curl

      - name: Show output received from web server
        debug:
          msg: "Output bootstrap.ign: {{ bootstrap_curl.stdout[:12] }}"

      - name: Stop if ignition config isn't available
        fail:
        when: bootstrap_curl.stdout[:12] != "{\"ignition\":"